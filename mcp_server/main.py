# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T08:58:55+00:00



import argparse
import json
import os
from typing import *
from typing import Optional, Union

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import BaseSecurity, HTTPBasic
from fastapi import Path, Query, UploadFile

from models import (
    BundleInfo,
    BundlesIgnored,
    DefaultGroups,
    InstallStatus,
    JcrContentProtocolHTTPHeaders,
    KeystoreInfo,
    Path,
    Propertylist,
    ProxyExceptions,
    PwdresetAuthorizables,
    SamlConfigurationInfo,
    SynchronizeAttributes,
    TruststoreInfo,
)
from models.SystemConsoleStatus_productinfo import JsonGetResponse

app = MCPProxy(
    contact={
        'email': 'opensource@shinesolutions.com',
        'name': 'Shine Solutions',
        'url': 'http://shinesolutions.com',
        'x-twitter': 'Adobe',
    },
    description='Swagger AEM is an OpenAPI specification for Adobe Experience Manager (AEM) API',
    title='Adobe Experience Manager (AEM) API',
    version='3.7.1-pre.0',
    servers=[{'url': '/'}, {'url': 'http://adobe.local'}],
)


@app.post(
    '/.cqactions.html',
    tags=['user_account_management', 'saml_settings_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_cq_actions(
    authorizable_id: str = Query(..., alias='authorizableId'), changelog: str = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/system/config/com.adobe.granite.auth.saml.SamlAuthenticationHandler.config',
    tags=[
        'saml_authentication_setup',
        'user_account_management',
        'saml_settings_management',
    ],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_config_adobe_granite_saml_authentication_handler(
    key_store_password: Optional[str] = Query(None, alias='keyStorePassword'),
    key_store_password__type_hint: Optional[str] = Query(
        None, alias='keyStorePassword@TypeHint'
    ),
    service_ranking: Optional[int] = Query(None, alias='service.ranking'),
    service_ranking__type_hint: Optional[str] = Query(
        None, alias='service.ranking@TypeHint'
    ),
    idp_http_redirect: Optional[bool] = Query(None, alias='idpHttpRedirect'),
    idp_http_redirect__type_hint: Optional[str] = Query(
        None, alias='idpHttpRedirect@TypeHint'
    ),
    create_user: Optional[bool] = Query(None, alias='createUser'),
    create_user__type_hint: Optional[str] = Query(None, alias='createUser@TypeHint'),
    default_redirect_url: Optional[str] = Query(None, alias='defaultRedirectUrl'),
    default_redirect_url__type_hint: Optional[str] = Query(
        None, alias='defaultRedirectUrl@TypeHint'
    ),
    user_i_d_attribute: Optional[str] = Query(None, alias='userIDAttribute'),
    user_i_d_attribute__type_hint: Optional[str] = Query(
        None, alias='userIDAttribute@TypeHint'
    ),
    default_groups: Optional[DefaultGroups] = Query(None, alias='defaultGroups'),
    default_groups__type_hint: Optional[str] = Query(
        None, alias='defaultGroups@TypeHint'
    ),
    idp_cert_alias: Optional[str] = Query(None, alias='idpCertAlias'),
    idp_cert_alias__type_hint: Optional[str] = Query(
        None, alias='idpCertAlias@TypeHint'
    ),
    add_group_memberships: Optional[bool] = Query(None, alias='addGroupMemberships'),
    add_group_memberships__type_hint: Optional[str] = Query(
        None, alias='addGroupMemberships@TypeHint'
    ),
    path: Optional[Path] = None,
    path__type_hint: Optional[str] = Query(None, alias='path@TypeHint'),
    synchronize_attributes: Optional[SynchronizeAttributes] = Query(
        None, alias='synchronizeAttributes'
    ),
    synchronize_attributes__type_hint: Optional[str] = Query(
        None, alias='synchronizeAttributes@TypeHint'
    ),
    clock_tolerance: Optional[int] = Query(None, alias='clockTolerance'),
    clock_tolerance__type_hint: Optional[str] = Query(
        None, alias='clockTolerance@TypeHint'
    ),
    group_membership_attribute: Optional[str] = Query(
        None, alias='groupMembershipAttribute'
    ),
    group_membership_attribute__type_hint: Optional[str] = Query(
        None, alias='groupMembershipAttribute@TypeHint'
    ),
    idp_url: Optional[str] = Query(None, alias='idpUrl'),
    idp_url__type_hint: Optional[str] = Query(None, alias='idpUrl@TypeHint'),
    logout_url: Optional[str] = Query(None, alias='logoutUrl'),
    logout_url__type_hint: Optional[str] = Query(None, alias='logoutUrl@TypeHint'),
    service_provider_entity_id: Optional[str] = Query(
        None, alias='serviceProviderEntityId'
    ),
    service_provider_entity_id__type_hint: Optional[str] = Query(
        None, alias='serviceProviderEntityId@TypeHint'
    ),
    assertion_consumer_service_u_r_l: Optional[str] = Query(
        None, alias='assertionConsumerServiceURL'
    ),
    assertion_consumer_service_u_r_l__type_hint: Optional[str] = Query(
        None, alias='assertionConsumerServiceURL@TypeHint'
    ),
    handle_logout: Optional[bool] = Query(None, alias='handleLogout'),
    handle_logout__type_hint: Optional[str] = Query(
        None, alias='handleLogout@TypeHint'
    ),
    sp_private_key_alias: Optional[str] = Query(None, alias='spPrivateKeyAlias'),
    sp_private_key_alias__type_hint: Optional[str] = Query(
        None, alias='spPrivateKeyAlias@TypeHint'
    ),
    use_encryption: Optional[bool] = Query(None, alias='useEncryption'),
    use_encryption__type_hint: Optional[str] = Query(
        None, alias='useEncryption@TypeHint'
    ),
    name_id_format: Optional[str] = Query(None, alias='nameIdFormat'),
    name_id_format__type_hint: Optional[str] = Query(
        None, alias='nameIdFormat@TypeHint'
    ),
    digest_method: Optional[str] = Query(None, alias='digestMethod'),
    digest_method__type_hint: Optional[str] = Query(
        None, alias='digestMethod@TypeHint'
    ),
    signature_method: Optional[str] = Query(None, alias='signatureMethod'),
    signature_method__type_hint: Optional[str] = Query(
        None, alias='signatureMethod@TypeHint'
    ),
    user_intermediate_path: Optional[str] = Query(None, alias='userIntermediatePath'),
    user_intermediate_path__type_hint: Optional[str] = Query(
        None, alias='userIntermediatePath@TypeHint'
    ),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/system/config/com.shinesolutions.aem.passwordreset.Activator',
    tags=['user_account_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_config_aem_password_reset(
    pwdreset_authorizables: Optional[PwdresetAuthorizables] = Query(
        None, alias='pwdreset.authorizables'
    ),
    pwdreset_authorizables__type_hint: Optional[str] = Query(
        None, alias='pwdreset.authorizables@TypeHint'
    ),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/system/config/com.shinesolutions.healthcheck.hc.impl.ActiveBundleHealthCheck',
    tags=['bundle_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_config_aem_health_check_servlet(
    bundles_ignored: Optional[BundlesIgnored] = Query(None, alias='bundles.ignored'),
    bundles_ignored__type_hint: Optional[str] = Query(
        None, alias='bundles.ignored@TypeHint'
    ),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/system/config/org.apache.felix.http',
    tags=[
        'http_service_setup',
        'ssl_settings_management',
        'truststore_configuration',
        'keystore_operations',
    ],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_config_apache_felix_jetty_based_http_service(
    org_apache_felix_https_nio: Optional[bool] = Query(
        None, alias='org.apache.felix.https.nio'
    ),
    org_apache_felix_https_nio__type_hint: Optional[str] = Query(
        None, alias='org.apache.felix.https.nio@TypeHint'
    ),
    org_apache_felix_https_keystore: Optional[str] = Query(
        None, alias='org.apache.felix.https.keystore'
    ),
    org_apache_felix_https_keystore__type_hint: Optional[str] = Query(
        None, alias='org.apache.felix.https.keystore@TypeHint'
    ),
    org_apache_felix_https_keystore_password: Optional[str] = Query(
        None, alias='org.apache.felix.https.keystore.password'
    ),
    org_apache_felix_https_keystore_password__type_hint: Optional[str] = Query(
        None, alias='org.apache.felix.https.keystore.password@TypeHint'
    ),
    org_apache_felix_https_keystore_key: Optional[str] = Query(
        None, alias='org.apache.felix.https.keystore.key'
    ),
    org_apache_felix_https_keystore_key__type_hint: Optional[str] = Query(
        None, alias='org.apache.felix.https.keystore.key@TypeHint'
    ),
    org_apache_felix_https_keystore_key_password: Optional[str] = Query(
        None, alias='org.apache.felix.https.keystore.key.password'
    ),
    org_apache_felix_https_keystore_key_password__type_hint: Optional[str] = Query(
        None, alias='org.apache.felix.https.keystore.key.password@TypeHint'
    ),
    org_apache_felix_https_truststore: Optional[str] = Query(
        None, alias='org.apache.felix.https.truststore'
    ),
    org_apache_felix_https_truststore__type_hint: Optional[str] = Query(
        None, alias='org.apache.felix.https.truststore@TypeHint'
    ),
    org_apache_felix_https_truststore_password: Optional[str] = Query(
        None, alias='org.apache.felix.https.truststore.password'
    ),
    org_apache_felix_https_truststore_password__type_hint: Optional[str] = Query(
        None, alias='org.apache.felix.https.truststore.password@TypeHint'
    ),
    org_apache_felix_https_clientcertificate: Optional[str] = Query(
        None, alias='org.apache.felix.https.clientcertificate'
    ),
    org_apache_felix_https_clientcertificate__type_hint: Optional[str] = Query(
        None, alias='org.apache.felix.https.clientcertificate@TypeHint'
    ),
    org_apache_felix_https_enable: Optional[bool] = Query(
        None, alias='org.apache.felix.https.enable'
    ),
    org_apache_felix_https_enable__type_hint: Optional[str] = Query(
        None, alias='org.apache.felix.https.enable@TypeHint'
    ),
    org_osgi_service_http_port_secure: Optional[str] = Query(
        None, alias='org.osgi.service.http.port.secure'
    ),
    org_osgi_service_http_port_secure__type_hint: Optional[str] = Query(
        None, alias='org.osgi.service.http.port.secure@TypeHint'
    ),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/system/config/org.apache.http.proxyconfigurator.config',
    tags=['http_service_setup'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_config_apache_http_components_proxy_configuration(
    proxy_host: Optional[str] = Query(None, alias='proxy.host'),
    proxy_host__type_hint: Optional[str] = Query(None, alias='proxy.host@TypeHint'),
    proxy_port: Optional[int] = Query(None, alias='proxy.port'),
    proxy_port__type_hint: Optional[str] = Query(None, alias='proxy.port@TypeHint'),
    proxy_exceptions: Optional[ProxyExceptions] = Query(None, alias='proxy.exceptions'),
    proxy_exceptions__type_hint: Optional[str] = Query(
        None, alias='proxy.exceptions@TypeHint'
    ),
    proxy_enabled: Optional[bool] = Query(None, alias='proxy.enabled'),
    proxy_enabled__type_hint: Optional[str] = Query(
        None, alias='proxy.enabled@TypeHint'
    ),
    proxy_user: Optional[str] = Query(None, alias='proxy.user'),
    proxy_user__type_hint: Optional[str] = Query(None, alias='proxy.user@TypeHint'),
    proxy_password: Optional[str] = Query(None, alias='proxy.password'),
    proxy_password__type_hint: Optional[str] = Query(
        None, alias='proxy.password@TypeHint'
    ),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/system/config/org.apache.sling.jcr.davex.impl.servlets.SlingDavExServlet',
    tags=['http_service_setup', 'system_property_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_config_apache_sling_dav_ex_servlet(
    alias: Optional[str] = None,
    alias__type_hint: Optional[str] = Query(None, alias='alias@TypeHint'),
    dav_create_absolute_uri: Optional[bool] = Query(
        None, alias='dav.create-absolute-uri'
    ),
    dav_create_absolute_uri__type_hint: Optional[str] = Query(
        None, alias='dav.create-absolute-uri@TypeHint'
    ),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/system/config/org.apache.sling.security.impl.ReferrerFilter',
    tags=['http_service_setup', 'system_property_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_config_apache_sling_referrer_filter(
    allow_empty: Optional[bool] = Query(None, alias='allow.empty'),
    allow_empty__type_hint: Optional[str] = Query(None, alias='allow.empty@TypeHint'),
    allow_hosts: Optional[str] = Query(None, alias='allow.hosts'),
    allow_hosts__type_hint: Optional[str] = Query(None, alias='allow.hosts@TypeHint'),
    allow_hosts_regexp: Optional[str] = Query(None, alias='allow.hosts.regexp'),
    allow_hosts_regexp__type_hint: Optional[str] = Query(
        None, alias='allow.hosts.regexp@TypeHint'
    ),
    filter_methods: Optional[str] = Query(None, alias='filter.methods'),
    filter_methods__type_hint: Optional[str] = Query(
        None, alias='filter.methods@TypeHint'
    ),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/system/config/org.apache.sling.servlets.get.DefaultGetServlet',
    tags=['data_query_execution', 'system_property_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_config_apache_sling_get_servlet(
    json_maximumresults: Optional[str] = Query(None, alias='json.maximumresults'),
    json_maximumresults__type_hint: Optional[str] = Query(
        None, alias='json.maximumresults@TypeHint'
    ),
    enable_html: Optional[bool] = Query(None, alias='enable.html'),
    enable_html__type_hint: Optional[str] = Query(None, alias='enable.html@TypeHint'),
    enable_txt: Optional[bool] = Query(None, alias='enable.txt'),
    enable_txt__type_hint: Optional[str] = Query(None, alias='enable.txt@TypeHint'),
    enable_xml: Optional[bool] = Query(None, alias='enable.xml'),
    enable_xml__type_hint: Optional[str] = Query(None, alias='enable.xml@TypeHint'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/system/config/{configNodeName}',
    tags=['node_management_operations', 'agent_configuration'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_config_property(config_node_name: str = Path(..., alias='configNodeName')):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bin/querybuilder.json',
    tags=['node_management_operations', 'data_query_execution'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_query(
    path: str,
    p_limit: float = Query(..., alias='p.limit'),
    field_1_property: str = Query(..., alias='1_property'),
    field_1_property_value: str = Query(..., alias='1_property.value'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/bin/querybuilder.json',
    tags=[
        'data_query_execution',
        'system_property_management',
        'node_management_operations',
    ],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_query(
    path: str,
    p_limit: float = Query(..., alias='p.limit'),
    field_1_property: str = Query(..., alias='1_property'),
    field_1_property_value: str = Query(..., alias='1_property.value'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/crx/explorer/ui/setpassword.jsp',
    tags=['saml_authentication_setup', 'saml_settings_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_set_password(old: str, plain: str = ..., verify: str = ...):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/crx/packmgr/installstatus.jsp',
    tags=['user_account_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_install_status():
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/crx/packmgr/service.jsp',
    tags=['user_account_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_package_service(cmd: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/crx/packmgr/service/.json/{path}',
    tags=[
        'software_package_management',
        'data_query_execution',
        'repository_operations',
    ],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_package_service_json(
    path: str,
    cmd: str = ...,
    group_name: Optional[str] = Query(None, alias='groupName'),
    package_name: Optional[str] = Query(None, alias='packageName'),
    package_version: Optional[str] = Query(None, alias='packageVersion'),
    field_charset_: Optional[str] = Query(None, alias='_charset_'),
    force: Optional[bool] = None,
    recursive: Optional[bool] = None,
    file: UploadFile = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/crx/packmgr/service/script.html',
    tags=[
        'saml_authentication_setup',
        'user_account_management',
        'http_service_setup',
        'software_package_management',
        'agent_configuration',
        'truststore_configuration',
        'ssl_settings_management',
        'system_health_monitoring',
        'data_query_execution',
        'system_property_management',
        'bundle_operations',
        'saml_settings_management',
        'repository_operations',
        'aem_product_health',
        'keystore_operations',
        'node_management_operations',
    ],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_package_manager_servlet():
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/crx/packmgr/update.jsp',
    tags=[
        'software_package_management',
        'system_property_management',
        'node_management_operations',
    ],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_package_update(
    group_name: str = Query(..., alias='groupName'),
    package_name: str = Query(..., alias='packageName'),
    version: str = ...,
    path: str = ...,
    filter: Optional[str] = None,
    field_charset_: Optional[str] = Query(None, alias='_charset_'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/crx/server/crx.default/jcr:root/.1.json',
    tags=['user_account_management', 'system_property_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_crxde_status():
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/etc/packages/{group}/{name}-{version}.zip',
    tags=['saml_authentication_setup', 'saml_settings_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_package(group: str, name: str = ..., version: str = ...):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/etc/packages/{group}/{name}-{version}.zip/jcr:content/vlt:definition/filter.tidy.2.json',
    tags=['saml_authentication_setup', 'saml_settings_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_package_filter(group: str, name: str = ..., version: str = ...):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/etc/replication/agents.{runmode}.-1.json',
    tags=['system_property_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_agents(runmode: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/etc/replication/agents.{runmode}/{name}',
    tags=['saml_authentication_setup', 'saml_settings_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def delete_agent(runmode: str, name: str = ...):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/etc/replication/agents.{runmode}/{name}',
    tags=['saml_authentication_setup', 'saml_settings_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_agent(runmode: str, name: str = ...):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/etc/replication/agents.{runmode}/{name}',
    tags=[
        'http_service_setup',
        'ssl_settings_management',
        'system_property_management',
        'repository_operations',
    ],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_agent(
    runmode: str,
    name: str = ...,
    jcr_content_cq_distribute: Optional[bool] = Query(
        None, alias='jcr:content/cq:distribute'
    ),
    jcr_content_cq_distribute__type_hint: Optional[str] = Query(
        None, alias='jcr:content/cq:distribute@TypeHint'
    ),
    jcr_content_cq_name: Optional[str] = Query(None, alias='jcr:content/cq:name'),
    jcr_content_cq_template: Optional[str] = Query(
        None, alias='jcr:content/cq:template'
    ),
    jcr_content_enabled: Optional[bool] = Query(None, alias='jcr:content/enabled'),
    jcr_content_jcr_description: Optional[str] = Query(
        None, alias='jcr:content/jcr:description'
    ),
    jcr_content_jcr_last_modified: Optional[str] = Query(
        None, alias='jcr:content/jcr:lastModified'
    ),
    jcr_content_jcr_last_modified_by: Optional[str] = Query(
        None, alias='jcr:content/jcr:lastModifiedBy'
    ),
    jcr_content_jcr_mixin_types: Optional[str] = Query(
        None, alias='jcr:content/jcr:mixinTypes'
    ),
    jcr_content_jcr_title: Optional[str] = Query(None, alias='jcr:content/jcr:title'),
    jcr_content_log_level: Optional[str] = Query(None, alias='jcr:content/logLevel'),
    jcr_content_no_status_update: Optional[bool] = Query(
        None, alias='jcr:content/noStatusUpdate'
    ),
    jcr_content_no_versioning: Optional[bool] = Query(
        None, alias='jcr:content/noVersioning'
    ),
    jcr_content_protocol_connect_timeout: Optional[float] = Query(
        None, alias='jcr:content/protocolConnectTimeout'
    ),
    jcr_content_protocol_h_t_t_p_connection_closed: Optional[bool] = Query(
        None, alias='jcr:content/protocolHTTPConnectionClosed'
    ),
    jcr_content_protocol_h_t_t_p_expired: Optional[str] = Query(
        None, alias='jcr:content/protocolHTTPExpired'
    ),
    jcr_content_protocol_h_t_t_p_headers: Optional[
        JcrContentProtocolHTTPHeaders
    ] = Query(None, alias='jcr:content/protocolHTTPHeaders'),
    jcr_content_protocol_h_t_t_p_headers__type_hint: Optional[str] = Query(
        None, alias='jcr:content/protocolHTTPHeaders@TypeHint'
    ),
    jcr_content_protocol_h_t_t_p_method: Optional[str] = Query(
        None, alias='jcr:content/protocolHTTPMethod'
    ),
    jcr_content_protocol_h_t_t_p_s_relaxed: Optional[bool] = Query(
        None, alias='jcr:content/protocolHTTPSRelaxed'
    ),
    jcr_content_protocol_interface: Optional[str] = Query(
        None, alias='jcr:content/protocolInterface'
    ),
    jcr_content_protocol_socket_timeout: Optional[float] = Query(
        None, alias='jcr:content/protocolSocketTimeout'
    ),
    jcr_content_protocol_version: Optional[str] = Query(
        None, alias='jcr:content/protocolVersion'
    ),
    jcr_content_proxy_n_t_l_m_domain: Optional[str] = Query(
        None, alias='jcr:content/proxyNTLMDomain'
    ),
    jcr_content_proxy_n_t_l_m_host: Optional[str] = Query(
        None, alias='jcr:content/proxyNTLMHost'
    ),
    jcr_content_proxy_host: Optional[str] = Query(None, alias='jcr:content/proxyHost'),
    jcr_content_proxy_password: Optional[str] = Query(
        None, alias='jcr:content/proxyPassword'
    ),
    jcr_content_proxy_port: Optional[float] = Query(
        None, alias='jcr:content/proxyPort'
    ),
    jcr_content_proxy_user: Optional[str] = Query(None, alias='jcr:content/proxyUser'),
    jcr_content_queue_batch_max_size: Optional[float] = Query(
        None, alias='jcr:content/queueBatchMaxSize'
    ),
    jcr_content_queue_batch_mode: Optional[str] = Query(
        None, alias='jcr:content/queueBatchMode'
    ),
    jcr_content_queue_batch_wait_time: Optional[float] = Query(
        None, alias='jcr:content/queueBatchWaitTime'
    ),
    jcr_content_retry_delay: Optional[str] = Query(
        None, alias='jcr:content/retryDelay'
    ),
    jcr_content_reverse_replication: Optional[bool] = Query(
        None, alias='jcr:content/reverseReplication'
    ),
    jcr_content_serialization_type: Optional[str] = Query(
        None, alias='jcr:content/serializationType'
    ),
    jcr_content_sling_resource_type: Optional[str] = Query(
        None, alias='jcr:content/sling:resourceType'
    ),
    jcr_content_ssl: Optional[str] = Query(None, alias='jcr:content/ssl'),
    jcr_content_transport_n_t_l_m_domain: Optional[str] = Query(
        None, alias='jcr:content/transportNTLMDomain'
    ),
    jcr_content_transport_n_t_l_m_host: Optional[str] = Query(
        None, alias='jcr:content/transportNTLMHost'
    ),
    jcr_content_transport_password: Optional[str] = Query(
        None, alias='jcr:content/transportPassword'
    ),
    jcr_content_transport_uri: Optional[str] = Query(
        None, alias='jcr:content/transportUri'
    ),
    jcr_content_transport_user: Optional[str] = Query(
        None, alias='jcr:content/transportUser'
    ),
    jcr_content_trigger_distribute: Optional[bool] = Query(
        None, alias='jcr:content/triggerDistribute'
    ),
    jcr_content_trigger_modified: Optional[bool] = Query(
        None, alias='jcr:content/triggerModified'
    ),
    jcr_content_trigger_on_off_time: Optional[bool] = Query(
        None, alias='jcr:content/triggerOnOffTime'
    ),
    jcr_content_trigger_receive: Optional[bool] = Query(
        None, alias='jcr:content/triggerReceive'
    ),
    jcr_content_trigger_specific: Optional[bool] = Query(
        None, alias='jcr:content/triggerSpecific'
    ),
    jcr_content_user_id: Optional[str] = Query(None, alias='jcr:content/userId'),
    jcr_primary_type: Optional[str] = Query(None, alias='jcr:primaryType'),
    field_operation: Optional[str] = Query(None, alias=':operation'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/etc/truststore',
    tags=['saml_authentication_setup', 'saml_settings_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_truststore_p_k_c_s12(file: UploadFile):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/etc/truststore/truststore.p12',
    tags=['saml_authentication_setup', 'saml_settings_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_truststore():
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/libs/granite/core/content/login.html', tags=['user_account_management'])
def get_login_page():
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/libs/granite/security/post/authorizables',
    tags=['user_account_management', 'saml_authentication_setup'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_authorizables(
    authorizable_id: str = Query(..., alias='authorizableId'),
    intermediate_path: str = Query(..., alias='intermediatePath'),
    create_user: Optional[str] = Query(None, alias='createUser'),
    create_group: Optional[str] = Query(None, alias='createGroup'),
    rep_password: Optional[str] = Query(None, alias='rep:password'),
    profile_given_name: Optional[str] = Query(None, alias='profile/givenName'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/libs/granite/security/post/sslSetup.html',
    tags=['ssl_settings_management', 'truststore_configuration', 'keystore_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def ssl_setup(
    keystore_password: str = Query(..., alias='keystorePassword'),
    keystore_password_confirm: str = Query(..., alias='keystorePasswordConfirm'),
    truststore_password: str = Query(..., alias='truststorePassword'),
    truststore_password_confirm: str = Query(..., alias='truststorePasswordConfirm'),
    https_hostname: str = Query(..., alias='httpsHostname'),
    https_port: str = Query(..., alias='httpsPort'),
    file: UploadFile = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/libs/granite/security/post/truststore',
    tags=['user_account_management', 'keystore_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_truststore(
    field_operation: Optional[str] = Query(None, alias=':operation'),
    new_password: Optional[str] = Query(None, alias='newPassword'),
    re_password: Optional[str] = Query(None, alias='rePassword'),
    key_store_type: Optional[str] = Query(None, alias='keyStoreType'),
    remove_alias: Optional[str] = Query(None, alias='removeAlias'),
    file: UploadFile = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/libs/granite/security/truststore.json',
    tags=['saml_authentication_setup', 'saml_settings_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_truststore_info():
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/libs/replication/treeactivation.html',
    tags=['node_management_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_tree_activation(
    ignoredeactivated: bool,
    onlymodified: bool = ...,
    path: str = ...,
    cmd: str = 'activate',
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/system/console/bundles/{name}',
    tags=['user_account_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_bundle(name: str, action: str = ...):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/system/console/bundles/{name}.json',
    tags=['user_account_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_bundle_info(name: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/system/console/configMgr',
    tags=[
        'saml_authentication_setup',
        'user_account_management',
        'http_service_setup',
        'software_package_management',
        'agent_configuration',
        'truststore_configuration',
        'ssl_settings_management',
        'system_health_monitoring',
        'data_query_execution',
        'system_property_management',
        'bundle_operations',
        'saml_settings_management',
        'repository_operations',
        'aem_product_health',
        'keystore_operations',
        'node_management_operations',
    ],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_config_mgr():
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/system/console/configMgr/com.adobe.granite.auth.saml.SamlAuthenticationHandler',
    tags=[
        'saml_authentication_setup',
        'user_account_management',
        'saml_settings_management',
    ],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_saml_configuration(
    post: Optional[bool] = None,
    apply: Optional[bool] = None,
    delete: Optional[bool] = None,
    action: Optional[str] = None,
    field_location: Optional[str] = Query(None, alias='$location'),
    path: Optional[Path] = None,
    service_ranking: Optional[int] = Query(None, alias='service.ranking'),
    idp_url: Optional[str] = Query(None, alias='idpUrl'),
    idp_cert_alias: Optional[str] = Query(None, alias='idpCertAlias'),
    idp_http_redirect: Optional[bool] = Query(None, alias='idpHttpRedirect'),
    service_provider_entity_id: Optional[str] = Query(
        None, alias='serviceProviderEntityId'
    ),
    assertion_consumer_service_u_r_l: Optional[str] = Query(
        None, alias='assertionConsumerServiceURL'
    ),
    sp_private_key_alias: Optional[str] = Query(None, alias='spPrivateKeyAlias'),
    key_store_password: Optional[str] = Query(None, alias='keyStorePassword'),
    default_redirect_url: Optional[str] = Query(None, alias='defaultRedirectUrl'),
    user_i_d_attribute: Optional[str] = Query(None, alias='userIDAttribute'),
    use_encryption: Optional[bool] = Query(None, alias='useEncryption'),
    create_user: Optional[bool] = Query(None, alias='createUser'),
    add_group_memberships: Optional[bool] = Query(None, alias='addGroupMemberships'),
    group_membership_attribute: Optional[str] = Query(
        None, alias='groupMembershipAttribute'
    ),
    default_groups: Optional[DefaultGroups] = Query(None, alias='defaultGroups'),
    name_id_format: Optional[str] = Query(None, alias='nameIdFormat'),
    synchronize_attributes: Optional[SynchronizeAttributes] = Query(
        None, alias='synchronizeAttributes'
    ),
    handle_logout: Optional[bool] = Query(None, alias='handleLogout'),
    logout_url: Optional[str] = Query(None, alias='logoutUrl'),
    clock_tolerance: Optional[int] = Query(None, alias='clockTolerance'),
    digest_method: Optional[str] = Query(None, alias='digestMethod'),
    signature_method: Optional[str] = Query(None, alias='signatureMethod'),
    user_intermediate_path: Optional[str] = Query(None, alias='userIntermediatePath'),
    propertylist: Optional[Propertylist] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/system/console/jmx/com.adobe.granite:type=Repository/op/{action}',
    tags=['user_account_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_jmx_repository(action: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/system/console/status-productinfo.json',
    tags=[
        'saml_authentication_setup',
        'user_account_management',
        'http_service_setup',
        'software_package_management',
        'agent_configuration',
        'truststore_configuration',
        'ssl_settings_management',
        'system_health_monitoring',
        'data_query_execution',
        'system_property_management',
        'bundle_operations',
        'saml_settings_management',
        'repository_operations',
        'aem_product_health',
        'keystore_operations',
        'node_management_operations',
    ],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_aem_product_info():
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/system/health',
    tags=['saml_authentication_setup', 'saml_settings_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_aem_health_check(
    tags: Optional[str] = None,
    combine_tags_or: Optional[bool] = Query(None, alias='combineTagsOr'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/{intermediatePath}/{authorizableId}.ks.html',
    tags=['user_account_management', 'keystore_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_authorizable_keystore(
    intermediate_path: str = Path(..., alias='intermediatePath'),
    authorizable_id: str = Path(..., alias='authorizableId'),
    field_operation: Optional[str] = Query(None, alias=':operation'),
    current_password: Optional[str] = Query(None, alias='currentPassword'),
    new_password: Optional[str] = Query(None, alias='newPassword'),
    re_password: Optional[str] = Query(None, alias='rePassword'),
    key_password: Optional[str] = Query(None, alias='keyPassword'),
    key_store_pass: Optional[str] = Query(None, alias='keyStorePass'),
    alias: Optional[str] = None,
    new_alias: Optional[str] = Query(None, alias='newAlias'),
    remove_alias: Optional[str] = Query(None, alias='removeAlias'),
    file: UploadFile = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/{intermediatePath}/{authorizableId}.ks.json',
    tags=['keystore_operations', 'saml_authentication_setup'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_authorizable_keystore(
    intermediate_path: str = Path(..., alias='intermediatePath'),
    authorizable_id: str = Path(..., alias='authorizableId'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/{intermediatePath}/{authorizableId}/keystore/store.p12',
    tags=[
        'saml_authentication_setup',
        'user_account_management',
        'agent_configuration',
        'truststore_configuration',
        'ssl_settings_management',
    ],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_keystore(
    intermediate_path: str = Path(..., alias='intermediatePath'),
    authorizable_id: str = Path(..., alias='authorizableId'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/{path}/',
    tags=['repository_operations', 'node_management_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_path(
    path: str,
    jcr_primary_type: str = Query(..., alias='jcr:primaryType'),
    field_name: str = Query(..., alias=':name'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/{path}/{name}',
    tags=['user_account_management', 'node_management_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def delete_node(path: str, name: str = ...):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/{path}/{name}',
    tags=['node_management_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_node(path: str, name: str = ...):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/{path}/{name}',
    tags=['node_management_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_node(
    path: str,
    name: str = ...,
    field_operation: Optional[str] = Query(None, alias=':operation'),
    delete_authorizable: Optional[str] = Query(None, alias='deleteAuthorizable'),
    file: UploadFile = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/{path}/{name}.rw.html',
    tags=['saml_authentication_setup', 'user_account_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_node_rw(
    path: str,
    name: str = ...,
    add_members: Optional[str] = Query(None, alias='addMembers'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
